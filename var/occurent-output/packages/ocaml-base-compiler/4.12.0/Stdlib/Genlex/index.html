<div><div class="odoc-spec"><div class="spec type" id="type-token" class="anchored"><a href="#type-token" class="anchor"></a><code><span><span class="keyword">type</span> token</span><span> = </span></code><table><tr id="type-token.Kwd" class="anchored"><td class="def variant constructor"><a href="#type-token.Kwd" class="anchor"></a><code><span>| </span><span><span class="constructor">Kwd</span> <span class="keyword">of</span> string</span></code></td></tr><tr id="type-token.Ident" class="anchored"><td class="def variant constructor"><a href="#type-token.Ident" class="anchor"></a><code><span>| </span><span><span class="constructor">Ident</span> <span class="keyword">of</span> string</span></code></td></tr><tr id="type-token.Int" class="anchored"><td class="def variant constructor"><a href="#type-token.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span> <span class="keyword">of</span> int</span></code></td></tr><tr id="type-token.Float" class="anchored"><td class="def variant constructor"><a href="#type-token.Float" class="anchor"></a><code><span>| </span><span><span class="constructor">Float</span> <span class="keyword">of</span> float</span></code></td></tr><tr id="type-token.String" class="anchored"><td class="def variant constructor"><a href="#type-token.String" class="anchor"></a><code><span>| </span><span><span class="constructor">String</span> <span class="keyword">of</span> string</span></code></td></tr><tr id="type-token.Char" class="anchored"><td class="def variant constructor"><a href="#type-token.Char" class="anchor"></a><code><span>| </span><span><span class="constructor">Char</span> <span class="keyword">of</span> char</span></code></td></tr></table></div><div class="spec-doc"><p>The type of tokens. The lexical classes are: <code>Int</code> and <code>Float</code> for integer and floating-point numbers; <code>String</code> for string literals, enclosed in double quotes; <code>Char</code> for character literals, enclosed in single quotes; <code>Ident</code> for identifiers (either sequences of letters, digits, underscores and quotes, or sequences of 'operator characters' such as <code>+</code>, <code>*</code>, etc); and <code>Kwd</code> for keywords (either identifiers or single 'special characters' such as <code>(</code>, <code>}</code>, etc).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_lexer" class="anchored"><a href="#val-make_lexer" class="anchor"></a><code><span><span class="keyword">val</span> make_lexer : <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="../Stream/index.html#type-t">Stream.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-token">token</a> <a href="../Stream/index.html#type-t">Stream.t</a></span></span></code></div><div class="spec-doc"><p>Construct the lexer function. The first argument is the list of keywords. An identifier <code>s</code> is returned as <code>Kwd s</code> if <code>s</code> belongs to this list, and as <code>Ident s</code> otherwise. A special character <code>s</code> is returned as <code>Kwd s</code> if <code>s</code> belongs to this list, and cause a lexical error (exception <a href="../Stream/index.html#exception-Error"><code>Stream.Error</code></a> with the offending lexeme as its parameter) otherwise. Blanks and newlines are skipped. Comments delimited by <code>(*</code> and <code>*)</code> are skipped as well, and can be nested. A <a href="../Stream/index.html#exception-Failure"><code>Stream.Failure</code></a> exception is raised if end of stream is unexpectedly reached.</p></div></div></div>